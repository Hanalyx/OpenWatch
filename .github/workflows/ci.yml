name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:  # Allow manual trigger

env:
  PYTHON_VERSION: '3.12'
  NODE_VERSION: '20'
  DOCKER_BUILDKIT: 1

jobs:
  # Backend Testing and Building
  backend:
    name: Backend CI
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15.10-alpine
        env:
          POSTGRES_USER: openwatch
          POSTGRES_PASSWORD: openwatch_test
          POSTGRES_DB: openwatch_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7.4.1-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

      mongodb:
        image: mongo:7.0
        options: >-
          --health-cmd "mongosh --eval 'db.adminCommand(\"ping\")'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 27017:27017

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio black==24.10.0 flake8 mypy bandit safety

      - name: Run linting
        working-directory: ./backend
        run: |
          echo "Running Black formatter check..."
          black --check app/

          echo "Running Flake8 linter..."
          flake8 app/ --max-line-length=120 --extend-ignore=E203,W503 --per-file-ignores='__init__.py:F401,E402'

          echo "Running type checking with mypy..."
          mypy app/ --ignore-missing-imports || true

      - name: Run security checks
        working-directory: ./backend
        run: |
          echo "Running Bandit security linter..."
          bandit -r app/ -f json -o bandit-report.json || true

          echo "Checking dependencies for vulnerabilities..."
          safety check --json || true

      - name: Run database migrations
        working-directory: ./backend
        env:
          OPENWATCH_DATABASE_URL: postgresql://openwatch:openwatch_test@localhost:5432/openwatch_test
          OPENWATCH_JWT_SECRET_KEY: test_secret_key_for_ci_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_SECRET_KEY: test_secret_key_for_ci_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_MASTER_KEY: test_master_key_for_ci_32bytes_long_minimum!!  # pragma: allowlist secret
          OPENWATCH_ENVIRONMENT: test
        run: |
          echo "Running Alembic database migrations..."
          # Migration chain consolidated to single head (20260128_merge_heads)
          alembic upgrade head
          echo "Migration step completed"

      - name: Run tests
        working-directory: ./backend
        env:
          # Database URLs for both app config and test fixtures
          OPENWATCH_DATABASE_URL: postgresql://openwatch:openwatch_test@localhost:5432/openwatch_test
          TEST_DATABASE_URL: postgresql://openwatch:openwatch_test@localhost:5432/openwatch_test
          OPENWATCH_REDIS_URL: redis://localhost:6379
          OPENWATCH_MONGODB_URL: mongodb://localhost:27017/openwatch_test
          OPENWATCH_JWT_SECRET_KEY: test_secret_key_for_ci_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_SECRET_KEY: test_secret_key_for_ci_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_MASTER_KEY: test_master_key_for_ci_32bytes_long_minimum!!  # pragma: allowlist secret
          OPENWATCH_ENVIRONMENT: test
          OPENWATCH_DEBUG: "true"
          OPENWATCH_AUDIT_LOG_FILE: ./logs/audit.log
          TESTING: true
        run: |
          # Create directory tree the app expects (matches Docker container layout)
          sudo mkdir -p /openwatch/logs/security /openwatch/security/keys
          sudo chmod -R 777 /openwatch
          mkdir -p logs

          # Check if tests directory exists
          if [ -d "tests" ] && [ "$(find tests -name '*.py' | head -1)" ]; then
            echo "Running pytest tests..."
            # Coverage threshold: incrementally raising toward 80%
            # Measured: 32% with 290+ tests (2026-01-31, E5 S1-S8 complete)
            # Threshold set at measured level; raise as coverage grows
            pytest tests/ -v --cov=app --cov-report=xml --cov-report=html --cov-fail-under=32
          else
            echo "Warning: No test files found in tests/ directory"
            echo "CI will pass without tests, but this should be addressed"
            echo "Consider adding at least basic smoke tests"
          fi

      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backend-coverage
          path: backend/htmlcov/

      - name: Build Docker image
        run: |
          docker build -f docker/Dockerfile.backend -t openwatch-backend:${{ github.sha }} .

  # Frontend Testing and Building
  frontend:
    name: Frontend CI
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Node.js
        uses: actions/setup-node@v5
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache Node modules
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run linting
        working-directory: ./frontend
        run: |
          echo "Running ESLint..."
          npm run lint

          echo "Running Prettier check..."
          npx prettier --check "src/**/*.{ts,tsx}" || echo "Prettier found formatting issues (non-blocking)"

          echo "Running TypeScript type check..."
          npx tsc --noEmit

      - name: Run tests with coverage
        working-directory: ./frontend
        run: |
          echo "Running Vitest with coverage..."
          npx vitest run --coverage

      - name: Upload frontend coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: frontend-coverage
          path: frontend/coverage/

      - name: Build application
        working-directory: ./frontend
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/dist/

      - name: Build Docker image
        run: |
          docker build -f docker/Dockerfile.frontend -t openwatch-frontend:${{ github.sha }} .

  # Integration Tests
  integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [backend, frontend]

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Compose
        run: |
          docker --version
          docker compose version

      - name: Generate TLS certificates for CI
        run: |
          # Create certificate directories required by docker-compose
          mkdir -p security/certs/mongodb security/keys security/certs

          # Generate self-signed CA and MongoDB certs for CI
          openssl req -x509 -newkey rsa:2048 -keyout security/certs/mongodb/ca.key \
            -out security/certs/mongodb/ca.crt -days 1 -nodes \
            -subj "/CN=CI-CA"

          openssl req -newkey rsa:2048 -keyout security/certs/mongodb/mongodb.key \
            -out security/certs/mongodb/mongodb.csr -nodes \
            -subj "/CN=mongodb"

          openssl x509 -req -in security/certs/mongodb/mongodb.csr \
            -CA security/certs/mongodb/ca.crt -CAkey security/certs/mongodb/ca.key \
            -CAcreateserial -out security/certs/mongodb/mongodb.crt -days 1

          # MongoDB expects combined PEM file
          cat security/certs/mongodb/mongodb.key security/certs/mongodb/mongodb.crt \
            > security/certs/mongodb/mongodb.pem

          # Generate frontend certs
          openssl req -x509 -newkey rsa:2048 -keyout security/keys/frontend.key \
            -out security/certs/frontend.crt -days 1 -nodes \
            -subj "/CN=localhost"

          echo "TLS certificates generated for CI"

      - name: Run integration tests
        env:
          POSTGRES_PASSWORD: openwatch_ci_test  # pragma: allowlist secret
          REDIS_PASSWORD: redis_ci_test  # pragma: allowlist secret
          MONGO_ROOT_USER: openwatch
          MONGO_ROOT_PASSWORD: mongo_ci_test  # pragma: allowlist secret
          OPENWATCH_SECRET_KEY: ci_test_secret_key_must_be_32_chars_minimum!!  # pragma: allowlist secret
          MASTER_KEY: ci_test_master_key_must_be_32_chars_minimum!!  # pragma: allowlist secret
          OPENWATCH_ENCRYPTION_KEY: ci_test_encryption_key_32chars!!
        run: |
          # Start infrastructure services only (skip app containers that need building)
          echo "Starting infrastructure services with docker-compose..."
          docker compose up -d database redis mongodb

          # Wait for services to be ready
          echo "Waiting for infrastructure services..."
          sleep 30

          # Check service health with retries
          echo "Checking service health..."
          for i in {1..6}; do
            HEALTHY=true

            if docker compose exec -T database pg_isready -U openwatch -d openwatch >/dev/null 2>&1; then
              echo "PostgreSQL: OK"
            else
              echo "PostgreSQL: not ready (attempt $i/6)"
              HEALTHY=false
            fi

            if docker compose exec -T redis redis-cli -a "$REDIS_PASSWORD" ping 2>/dev/null | grep -q PONG; then
              echo "Redis: OK"
            else
              echo "Redis: not ready (attempt $i/6)"
              HEALTHY=false
            fi

            if docker compose exec -T mongodb mongosh --host localhost:27017 \
                -u "$MONGO_ROOT_USER" -p "$MONGO_ROOT_PASSWORD" \
                --authenticationDatabase admin --quiet \
                --eval "db.runCommand({serverStatus: 1}).ok" 2>/dev/null | grep -q 1; then
              echo "MongoDB: OK"
            else
              echo "MongoDB: not ready (attempt $i/6)"
              HEALTHY=false
            fi

            if [ "$HEALTHY" = true ]; then
              echo "All infrastructure services healthy"
              break
            fi

            if [ "$i" -eq 6 ]; then
              echo "WARNING: Some services not healthy after 6 attempts"
            fi
            sleep 10
          done

          # Show service status
          echo "Service status:"
          docker compose ps

          # Show logs for debugging
          echo "Recent logs:"
          docker compose logs --tail=20

          # Clean up
          docker compose down -v

  # Detect what changed to optimize test runs
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      frontend_critical: ${{ steps.filter.outputs.frontend_critical }}
      e2e_required: ${{ steps.e2e_check.outputs.required }}
    steps:
      - uses: actions/checkout@v5

      - name: Detect file changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'docker/Dockerfile.backend'
            frontend:
              - 'frontend/**'
              - 'docker/Dockerfile.frontend'
            frontend_critical:
              - 'frontend/src/services/api.ts'
              - 'frontend/src/store/slices/authSlice.ts'
              - 'frontend/src/pages/auth/**'
              - 'frontend/src/components/auth/**'
              - 'frontend/e2e/**'

      - name: Determine if E2E is required
        id: e2e_check
        run: |
          # E2E required if:
          # 1. Backend changes (API changes may break E2E flows)
          # 2. Critical frontend changes (auth, API client)
          # 3. E2E test files changed
          # 4. Explicitly requested via label
          if [[ "${{ steps.filter.outputs.backend }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.frontend_critical }}" == "true" ]] || \
             [[ "${{ contains(github.event.pull_request.labels.*.name, 'run-e2e') }}" == "true" ]]; then
            echo "required=true" >> $GITHUB_OUTPUT
            echo "E2E tests required: backend=${{ steps.filter.outputs.backend }}, frontend_critical=${{ steps.filter.outputs.frontend_critical }}"
          else
            echo "required=false" >> $GITHUB_OUTPUT
            echo "E2E tests skipped: frontend-only non-critical changes"
          fi

  # E2E Testing - conditional based on changes
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [backend, frontend, changes]
    # Always run to satisfy required status check, but exit early if not needed
    env:
      E2E_REQUIRED: ${{ needs.changes.outputs.e2e_required == 'true' || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}

    services:
      postgres:
        image: postgres:15.10-alpine
        env:
          POSTGRES_USER: openwatch
          POSTGRES_PASSWORD: openwatch_test
          POSTGRES_DB: openwatch_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7.4.1-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

      mongodb:
        image: mongo:7.0-jammy
        env:
          MONGO_INITDB_ROOT_USERNAME: openwatch
          MONGO_INITDB_ROOT_PASSWORD: openwatch_test
          MONGO_INITDB_DATABASE: openwatch_rules
        options: >-
          --health-cmd "mongosh --eval 'db.runCommand({ping:1})' --quiet"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 27017:27017

    steps:
      - name: Skip E2E if not required
        if: env.E2E_REQUIRED != 'true'
        run: |
          echo "E2E tests skipped - no critical changes detected"
          echo "To force E2E tests, add the 'run-e2e' label to the PR"

      - name: Checkout code
        if: env.E2E_REQUIRED == 'true'
        uses: actions/checkout@v5

      - name: Set up Node.js
        if: env.E2E_REQUIRED == 'true'
        uses: actions/setup-node@v5
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install frontend dependencies
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./frontend
        run: npm ci

      - name: Install Playwright browsers
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./frontend
        run: npx playwright install --with-deps

      - name: Set up Python
        if: env.E2E_REQUIRED == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install backend dependencies
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run database migrations
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./backend
        env:
          OPENWATCH_DATABASE_URL: postgresql://openwatch:openwatch_test@localhost:5432/openwatch_test
          OPENWATCH_JWT_SECRET_KEY: test_secret_key_for_e2e_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_SECRET_KEY: test_secret_key_for_e2e_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_MASTER_KEY: test_master_key_for_e2e_32bytes_long_minimum!!  # pragma: allowlist secret
          OPENWATCH_ENVIRONMENT: test
        run: |
          echo "Running Alembic database migrations..."
          alembic upgrade head
          echo "Migration completed"

      - name: Start backend service
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./backend
        env:
          OPENWATCH_DATABASE_URL: postgresql://openwatch:openwatch_test@localhost:5432/openwatch_test
          OPENWATCH_REDIS_URL: redis://localhost:6379
          OPENWATCH_MONGODB_URL: mongodb://openwatch:openwatch_test@localhost:27017/openwatch_rules?authSource=admin
          OPENWATCH_JWT_SECRET_KEY: test_secret_key_for_e2e_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_SECRET_KEY: test_secret_key_for_e2e_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_MASTER_KEY: test_master_key_for_e2e_32bytes_long_minimum!!  # pragma: allowlist secret
          OPENWATCH_ENVIRONMENT: test
          OPENWATCH_AUDIT_LOG_FILE: ./logs/audit.log
          OPENWATCH_REQUIRE_HTTPS: "false"
          OPENWATCH_DEBUG: "true"
          TESTING: true
        run: |
          # Create directory tree the app expects (Docker container convention)
          # In CI we run directly on the host, not in a container
          sudo mkdir -p /openwatch/logs/security /openwatch/data/scap /openwatch/data/results/rule_scans /openwatch/data/oval_definitions /openwatch/security/keys
          sudo chmod -R 777 /openwatch
          mkdir -p logs

          # Start backend in background
          python -m uvicorn app.main:app --host 0.0.0.0 --port 8000 &

          # Wait for backend to start
          timeout 60 bash -c 'until curl -f http://localhost:8000/health; do sleep 2; done'

      - name: Create test data
        if: env.E2E_REQUIRED == 'true'
        continue-on-error: true
        run: |
          # Wait for backend to be fully ready (not just health endpoint)
          echo "Waiting for backend API to be fully operational..."
          sleep 5

          # Create test users via API
          # Valid roles: super_admin, security_admin, security_analyst, compliance_officer, auditor, guest
          echo "Creating admin test user..."
          ADMIN_RESPONSE=$(curl -s -X POST http://localhost:8000/api/auth/register \
            -H "Content-Type: application/json" \
            -d '{
              "username": "admin@openwatch.local",
              "email": "admin@openwatch.local",
              "password": "Admin123!@#",
              "role": "super_admin"
            }')
          echo "Admin registration response: $ADMIN_RESPONSE"

          echo "Creating analyst test user..."
          ANALYST_RESPONSE=$(curl -s -X POST http://localhost:8000/api/auth/register \
            -H "Content-Type: application/json" \
            -d '{
              "username": "analyst@openwatch.local",
              "email": "analyst@openwatch.local",
              "password": "Analyst123!@#",
              "role": "security_analyst"
            }')
          echo "Analyst registration response: $ANALYST_RESPONSE"

          echo "Creating auditor test user..."
          AUDITOR_RESPONSE=$(curl -s -X POST http://localhost:8000/api/auth/register \
            -H "Content-Type: application/json" \
            -d '{
              "username": "auditor@openwatch.local",
              "email": "auditor@openwatch.local",
              "password": "Auditor123!@#",
              "role": "auditor"
            }')
          echo "Auditor registration response: $AUDITOR_RESPONSE"

          # Verify at least one user can log in (don't fail if login doesn't work)
          echo "Verifying login works..."
          LOGIN_RESPONSE=$(curl -s -X POST http://localhost:8000/api/auth/login \
            -H "Content-Type: application/json" \
            -d '{
              "username": "admin@openwatch.local",
              "password": "Admin123!@#"
            }' || echo '{}')

          if echo "$LOGIN_RESPONSE" | grep -q "access_token"; then
            echo "Login verification successful"
          else
            echo "WARNING: Login verification failed. Response: $LOGIN_RESPONSE"
            echo "E2E tests will proceed - tests handle their own auth setup"
          fi

      - name: Run E2E tests
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./frontend
        env:
          CI: true
          BASE_URL: http://localhost:3001
          API_URL: http://localhost:8000
        run: |
          # Playwright's webServer config starts the frontend automatically
          # Run E2E tests (chromium only in CI to keep runtime reasonable)
          npx playwright test --project=chromium --reporter=html,junit

      - name: Upload E2E test results
        uses: actions/upload-artifact@v4
        if: always() && env.E2E_REQUIRED == 'true'
        with:
          name: e2e-test-results
          path: |
            frontend/test-results/
            frontend/playwright-report/
            frontend/junit.xml

      - name: Upload E2E screenshots on failure
        uses: actions/upload-artifact@v4
        if: failure() && env.E2E_REQUIRED == 'true'
        with:
          name: e2e-failure-screenshots
          path: frontend/test-results/screenshots/

  # Build and push Docker images (only on main branch)
  docker:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [backend, frontend, integration, e2e, changes]
    # Run on main push if core tests pass (e2e may be skipped for frontend-only changes)
    if: |
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push' &&
      needs.backend.result == 'success' &&
      needs.frontend.result == 'success' &&
      needs.integration.result == 'success' &&
      (needs.e2e.result == 'success' || needs.e2e.result == 'skipped')

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v4
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile.backend
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/openwatch-backend:latest
            ghcr.io/${{ github.repository_owner }}/openwatch-backend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile.frontend
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/openwatch-frontend:latest
            ghcr.io/${{ github.repository_owner }}/openwatch-frontend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
