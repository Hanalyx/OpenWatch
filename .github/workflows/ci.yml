name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:  # Allow manual trigger

env:
  PYTHON_VERSION: '3.12'
  NODE_VERSION: '20'
  DOCKER_BUILDKIT: 1

jobs:
  # Backend Testing and Building
  backend:
    name: Backend CI
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15.10-alpine
        env:
          POSTGRES_USER: openwatch
          POSTGRES_PASSWORD: openwatch_test
          POSTGRES_DB: openwatch_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7.4.1-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache Python dependencies
        uses: actions/cache@v5
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio black==24.10.0 flake8 mypy bandit safety

      - name: Run linting
        working-directory: ./backend
        run: |
          echo "Running Black formatter check..."
          black --check app/

          echo "Running Flake8 linter..."
          flake8 app/ --max-line-length=120 --extend-ignore=E203,W503 --per-file-ignores='__init__.py:F401,E402'

          echo "Running type checking with mypy..."
          mypy app/ --ignore-missing-imports || true

      - name: Run security checks
        working-directory: ./backend
        run: |
          echo "Running Bandit security linter..."
          bandit -r app/ -f json -o bandit-report.json || true

          echo "Checking dependencies for vulnerabilities..."
          safety check --json || true

      - name: Run database migrations
        working-directory: ./backend
        env:
          OPENWATCH_DATABASE_URL: postgresql://openwatch:openwatch_test@localhost:5432/openwatch_test
          OPENWATCH_JWT_SECRET_KEY: test_secret_key_for_ci_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_SECRET_KEY: test_secret_key_for_ci_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_MASTER_KEY: test_master_key_for_ci_32bytes_long_minimum!!  # pragma: allowlist secret
          OPENWATCH_ENVIRONMENT: test
        run: |
          echo "Running Alembic database migrations..."
          # Migration chain consolidated to single head (20260128_merge_heads)
          alembic upgrade head
          echo "Migration step completed"

      - name: Run tests
        working-directory: ./backend
        env:
          # Database URLs for both app config and test fixtures
          OPENWATCH_DATABASE_URL: postgresql://openwatch:openwatch_test@localhost:5432/openwatch_test
          TEST_DATABASE_URL: postgresql://openwatch:openwatch_test@localhost:5432/openwatch_test
          OPENWATCH_REDIS_URL: redis://localhost:6379
          OPENWATCH_JWT_SECRET_KEY: test_secret_key_for_ci_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_SECRET_KEY: test_secret_key_for_ci_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_MASTER_KEY: test_master_key_for_ci_32bytes_long_minimum!!  # pragma: allowlist secret
          OPENWATCH_ENVIRONMENT: test
          OPENWATCH_DEBUG: "true"
          OPENWATCH_AUDIT_LOG_FILE: ./logs/audit.log
          TESTING: true
        run: |
          # Create directory tree the app expects (matches Docker container layout)
          sudo mkdir -p /openwatch/logs/security /openwatch/security/keys
          sudo chmod -R 777 /openwatch
          mkdir -p logs

          # Check if tests directory exists
          if [ -d "tests" ] && [ "$(find tests -name '*.py' | head -1)" ]; then
            echo "Running pytest tests..."
            # Coverage threshold: incrementally raising toward 80%
            # Measured: 31.2% with 332 tests (2026-02-16)
            # Threshold set at measured level; raise as coverage grows
            pytest tests/ -v --cov=app --cov-report=xml --cov-report=html --cov-fail-under=31
          else
            echo "Warning: No test files found in tests/ directory"
            echo "CI will pass without tests, but this should be addressed"
            echo "Consider adding at least basic smoke tests"
          fi

      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v7
        with:
          name: backend-coverage
          path: backend/htmlcov/

      - name: Build Docker image
        run: |
          docker build -f docker/Dockerfile.backend -t openwatch-backend:${{ github.sha }} .

  # Frontend Testing and Building
  frontend:
    name: Frontend CI
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Node.js
        uses: actions/setup-node@v5
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache Node modules
        uses: actions/cache@v5
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run linting
        working-directory: ./frontend
        run: |
          echo "Running ESLint..."
          npm run lint

          echo "Running Prettier check..."
          npx prettier --check "src/**/*.{ts,tsx}" || echo "Prettier found formatting issues (non-blocking)"

          echo "Running TypeScript type check..."
          npx tsc --noEmit

      - name: Run tests with coverage
        working-directory: ./frontend
        run: |
          echo "Running Vitest with coverage..."
          npx vitest run --coverage

      - name: Upload frontend coverage
        if: always()
        uses: actions/upload-artifact@v7
        with:
          name: frontend-coverage
          path: frontend/coverage/

      - name: Build application
        working-directory: ./frontend
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v7
        with:
          name: frontend-build
          path: frontend/dist/

      - name: Build Docker image
        run: |
          docker build -f docker/Dockerfile.frontend -t openwatch-frontend:${{ github.sha }} .

  # Detect what changed to optimize test runs
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      frontend_critical: ${{ steps.filter.outputs.frontend_critical }}
      e2e_required: ${{ steps.e2e_check.outputs.required }}
    steps:
      - uses: actions/checkout@v5

      - name: Detect file changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'backend/**'
              - 'docker/Dockerfile.backend'
            frontend:
              - 'frontend/**'
              - 'docker/Dockerfile.frontend'
            frontend_critical:
              - 'frontend/src/services/api.ts'
              - 'frontend/src/store/slices/authSlice.ts'
              - 'frontend/src/pages/auth/**'
              - 'frontend/src/components/auth/**'
              - 'frontend/e2e/**'

      - name: Determine if E2E is required
        id: e2e_check
        run: |
          # E2E required if:
          # 1. Backend changes (API changes may break E2E flows)
          # 2. Critical frontend changes (auth, API client)
          # 3. E2E test files changed
          # 4. Explicitly requested via label
          if [[ "${{ steps.filter.outputs.backend }}" == "true" ]] || \
             [[ "${{ steps.filter.outputs.frontend_critical }}" == "true" ]] || \
             [[ "${{ contains(github.event.pull_request.labels.*.name, 'run-e2e') }}" == "true" ]]; then
            echo "required=true" >> $GITHUB_OUTPUT
            echo "E2E tests required: backend=${{ steps.filter.outputs.backend }}, frontend_critical=${{ steps.filter.outputs.frontend_critical }}"
          else
            echo "required=false" >> $GITHUB_OUTPUT
            echo "E2E tests skipped: frontend-only non-critical changes"
          fi

  # E2E Testing - conditional based on changes
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [backend, frontend, changes]
    # Always run to satisfy required status check, but exit early if not needed
    env:
      E2E_REQUIRED: ${{ needs.changes.outputs.e2e_required == 'true' || (github.event_name == 'push' && github.ref == 'refs/heads/main') }}

    services:
      postgres:
        image: postgres:15.10-alpine
        env:
          POSTGRES_USER: openwatch
          POSTGRES_PASSWORD: openwatch_test
          POSTGRES_DB: openwatch_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7.4.1-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Skip E2E if not required
        if: env.E2E_REQUIRED != 'true'
        run: |
          echo "E2E tests skipped - no critical changes detected"
          echo "To force E2E tests, add the 'run-e2e' label to the PR"

      - name: Checkout code
        if: env.E2E_REQUIRED == 'true'
        uses: actions/checkout@v5

      - name: Set up Node.js
        if: env.E2E_REQUIRED == 'true'
        uses: actions/setup-node@v5
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install frontend dependencies
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./frontend
        run: npm ci

      - name: Install Playwright browsers
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./frontend
        run: npx playwright install --with-deps

      - name: Set up Python
        if: env.E2E_REQUIRED == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install backend dependencies
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run database migrations
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./backend
        env:
          OPENWATCH_DATABASE_URL: postgresql://openwatch:openwatch_test@localhost:5432/openwatch_test
          OPENWATCH_JWT_SECRET_KEY: test_secret_key_for_e2e_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_SECRET_KEY: test_secret_key_for_e2e_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_MASTER_KEY: test_master_key_for_e2e_32bytes_long_minimum!!  # pragma: allowlist secret
          OPENWATCH_ENVIRONMENT: test
        run: |
          echo "Running Alembic database migrations..."
          alembic upgrade head
          echo "Migration completed"

      - name: Start backend service
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./backend
        env:
          OPENWATCH_DATABASE_URL: postgresql://openwatch:openwatch_test@localhost:5432/openwatch_test
          OPENWATCH_REDIS_URL: redis://localhost:6379
          OPENWATCH_JWT_SECRET_KEY: test_secret_key_for_e2e_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_SECRET_KEY: test_secret_key_for_e2e_must_be_32_chars_minimum  # pragma: allowlist secret
          OPENWATCH_MASTER_KEY: test_master_key_for_e2e_32bytes_long_minimum!!  # pragma: allowlist secret
          OPENWATCH_ENVIRONMENT: test
          OPENWATCH_AUDIT_LOG_FILE: ./logs/audit.log
          OPENWATCH_REQUIRE_HTTPS: "false"
          OPENWATCH_DEBUG: "true"
          TESTING: true
        run: |
          # Create directory tree the app expects (Docker container convention)
          # In CI we run directly on the host, not in a container
          sudo mkdir -p /openwatch/logs/security /openwatch/data/scap /openwatch/data/results/rule_scans /openwatch/data/oval_definitions /openwatch/security/keys
          sudo chmod -R 777 /openwatch
          mkdir -p logs

          # Start backend in background
          python -m uvicorn app.main:app --host 0.0.0.0 --port 8000 &

          # Wait for backend to start
          timeout 60 bash -c 'until curl -f http://localhost:8000/health; do sleep 2; done'

      - name: Create test data
        if: env.E2E_REQUIRED == 'true'
        continue-on-error: true
        run: |
          # Wait for backend to be fully ready (not just health endpoint)
          echo "Waiting for backend API to be fully operational..."
          sleep 5

          # Create test users via API
          # Valid roles: super_admin, security_admin, security_analyst, compliance_officer, auditor, guest
          echo "Creating admin test user..."
          ADMIN_RESPONSE=$(curl -s -X POST http://localhost:8000/api/auth/register \
            -H "Content-Type: application/json" \
            -d '{
              "username": "admin@example.com",
              "email": "admin@example.com",
              "password": "Admin123!@#",
              "role": "super_admin"
            }')
          echo "Admin registration response: $ADMIN_RESPONSE"

          echo "Creating analyst test user..."
          ANALYST_RESPONSE=$(curl -s -X POST http://localhost:8000/api/auth/register \
            -H "Content-Type: application/json" \
            -d '{
              "username": "analyst@example.com",
              "email": "analyst@example.com",
              "password": "Analyst123!@#",
              "role": "security_analyst"
            }')
          echo "Analyst registration response: $ANALYST_RESPONSE"

          echo "Creating auditor test user..."
          AUDITOR_RESPONSE=$(curl -s -X POST http://localhost:8000/api/auth/register \
            -H "Content-Type: application/json" \
            -d '{
              "username": "auditor@example.com",
              "email": "auditor@example.com",
              "password": "Auditor123!@#",
              "role": "auditor"
            }')
          echo "Auditor registration response: $AUDITOR_RESPONSE"

          # Verify at least one user can log in (don't fail if login doesn't work)
          # Use default admin created by init_roles.py
          echo "Verifying login works..."
          # Test credentials from init_roles.py - NOT real secrets
          ADMIN_USER="admin"
          ADMIN_PASS="admin123"  # pragma: allowlist secret
          LOGIN_RESPONSE=$(curl -s -X POST http://localhost:8000/api/auth/login \
            -H "Content-Type: application/json" \
            -d "{\"username\": \"$ADMIN_USER\", \"password\": \"$ADMIN_PASS\"}" || echo '{}')

          if echo "$LOGIN_RESPONSE" | grep -q "access_token"; then
            echo "Login verification successful"
          else
            echo "WARNING: Login verification failed. Response: $LOGIN_RESPONSE"
            echo "E2E tests will proceed - tests handle their own auth setup"
          fi

      - name: Run E2E tests
        if: env.E2E_REQUIRED == 'true'
        working-directory: ./frontend
        env:
          CI: true
          BASE_URL: http://localhost:3001
          API_URL: http://localhost:8000
        run: |
          # Playwright's webServer config starts the frontend automatically
          # Run E2E tests (chromium only in CI to keep runtime reasonable)
          npx playwright test --project=chromium --reporter=html,junit

      - name: Upload E2E test results
        uses: actions/upload-artifact@v7
        if: always() && env.E2E_REQUIRED == 'true'
        with:
          name: e2e-test-results
          path: |
            frontend/test-results/
            frontend/playwright-report/
            frontend/junit.xml

      - name: Upload E2E screenshots on failure
        uses: actions/upload-artifact@v7
        if: failure() && env.E2E_REQUIRED == 'true'
        with:
          name: e2e-failure-screenshots
          path: frontend/test-results/screenshots/

  # Build and push Docker images (only on main branch)
  docker:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [backend, frontend, e2e, changes]
    # Run on main push if core tests pass (e2e may be skipped for frontend-only changes)
    if: |
      github.ref == 'refs/heads/main' &&
      github.event_name == 'push' &&
      needs.backend.result == 'success' &&
      needs.frontend.result == 'success' &&
      (needs.e2e.result == 'success' || needs.e2e.result == 'skipped')

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Convert repository name to lowercase
        id: repo
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "name=${REPO_LOWER}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile.backend
          push: true
          tags: |
            ghcr.io/${{ steps.repo.outputs.name }}-backend:latest
            ghcr.io/${{ steps.repo.outputs.name }}-backend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile.frontend
          push: true
          tags: |
            ghcr.io/${{ steps.repo.outputs.name }}-frontend:latest
            ghcr.io/${{ steps.repo.outputs.name }}-frontend:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
