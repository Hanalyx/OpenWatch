"""
Scan Report Generation Endpoints

This module provides endpoints for generating and downloading scan reports
in various formats (HTML, JSON, CSV) and retrieving scan results.

Endpoints:
    GET /{scan_id}/results       - Get scan results (primary results endpoint)
    GET /{scan_id}/report/html   - Download HTML report
    GET /{scan_id}/report/json   - Export results as JSON
    GET /{scan_id}/report/csv    - Export results as CSV
    GET /{scan_id}/failed-rules  - Get failed rules for AEGIS integration

Architecture Notes:
    - HTML reports are generated by oscap and stored on disk
    - JSON reports include enhanced rule details with remediation info
    - CSV reports provide spreadsheet-compatible summaries
    - Failed rules endpoint optimized for AEGIS integration

Security Notes:
    - All endpoints require JWT authentication
    - File paths validated before access
    - XML parsing uses standard library (not lxml) for basic parsing
"""

import csv
import io
import logging
import os
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import FileResponse, Response
from sqlalchemy import text
from sqlalchemy.orm import Session

from app.auth import get_current_user
from app.database import get_db
from app.utils.query_builder import QueryBuilder

logger = logging.getLogger(__name__)

router = APIRouter(tags=["Scan Reports"])


# =============================================================================
# HELPER FUNCTIONS
# =============================================================================


async def _get_scan_details(
    scan_id: str,
    db: Session,
    current_user: Dict[str, Any],
) -> Dict[str, Any]:
    """
    Get comprehensive scan details for report generation.

    Retrieves scan metadata, host information, and results summary.
    This is a helper function used by multiple report endpoints.

    Args:
        scan_id: UUID of the scan.
        db: SQLAlchemy database session.
        current_user: Authenticated user from JWT token.

    Returns:
        Dictionary with complete scan information.

    Raises:
        HTTPException 404: Scan not found.
    """
    import json

    builder = (
        QueryBuilder("scans s")
        .select(
            "s.id",
            "s.name",
            "s.host_id",
            "s.profile_id",
            "s.status",
            "s.progress",
            "s.result_file",
            "s.report_file",
            "s.error_message",
            "s.scan_options",
            "s.started_at",
            "s.completed_at",
            "s.started_by",
            "s.celery_task_id",
            "h.display_name as host_name",
            "h.hostname",
        )
        .join("hosts h", "s.host_id = h.id")
        .where("s.id = :id", scan_id, "id")
    )
    query, params = builder.build()
    result = db.execute(text(query), params).fetchone()

    if not result:
        raise HTTPException(status_code=404, detail="Scan not found")

    scan_options = {}
    if result.scan_options:
        try:
            scan_options = json.loads(result.scan_options)
        except Exception:
            pass

    scan_data: Dict[str, Any] = {
        "id": result.id,
        "name": result.name,
        "host_id": result.host_id,
        "host_name": result.host_name,
        "hostname": result.hostname,
        "profile_id": result.profile_id,
        "status": result.status,
        "progress": result.progress,
        "result_file": result.result_file,
        "report_file": result.report_file,
        "error_message": result.error_message,
        "scan_options": scan_options,
        "started_at": result.started_at.isoformat() if result.started_at else None,
        "completed_at": (result.completed_at.isoformat() if result.completed_at else None),
        "started_by": result.started_by,
        "celery_task_id": result.celery_task_id,
    }

    # Add results summary if scan is completed
    if result.status == "completed":
        results = db.execute(
            text(
                """
            SELECT total_rules, passed_rules, failed_rules, error_rules,
                   unknown_rules, not_applicable_rules, score,
                   severity_high, severity_medium, severity_low
            FROM scan_results WHERE scan_id = :scan_id
        """
            ),
            {"scan_id": scan_id},
        ).fetchone()

        if results:
            scan_data["results"] = {
                "total_rules": results.total_rules,
                "passed_rules": results.passed_rules,
                "failed_rules": results.failed_rules,
                "error_rules": results.error_rules,
                "unknown_rules": results.unknown_rules,
                "not_applicable_rules": results.not_applicable_rules,
                "score": results.score,
                "severity_high": results.severity_high,
                "severity_medium": results.severity_medium,
                "severity_low": results.severity_low,
            }

    return scan_data


# =============================================================================
# RESULTS ENDPOINT
# =============================================================================


@router.get("/{scan_id}/results")
async def get_scan_results(
    scan_id: str,
    include_rules: bool = False,
    db: Session = Depends(get_db),
    current_user: Dict[str, Any] = Depends(get_current_user),
) -> Dict[str, Any]:
    """
    Get scan results summary.

    Returns comprehensive scan results including compliance scores, severity
    distribution, and optionally detailed rule-level results.

    This is the primary endpoint for retrieving scan results data.
    For formatted reports (HTML, CSV), use the /report/* endpoints.

    Args:
        scan_id: UUID of the scan.
        include_rules: If True, include detailed rule-level results (slower).
        db: SQLAlchemy database session.
        current_user: Authenticated user from JWT token.

    Returns:
        Dictionary with scan metadata and results summary.

    Raises:
        HTTPException 404: Scan not found.
        HTTPException 500: Results retrieval failure.

    Example:
        GET /api/scans/550e8400-e29b-41d4-a716-446655440000/results
        GET /api/scans/550e8400-e29b-41d4-a716-446655440000/results?include_rules=true

    Response Format:
        {
            "scan_id": "uuid",
            "status": "completed",
            "host": {
                "id": "uuid",
                "hostname": "server.example.com",
                "ip_address": "192.168.1.100"
            },
            "results": {
                "total_rules": 100,
                "passed_rules": 85,
                "failed_rules": 12,
                "error_rules": 3,
                "score": "85.0%",
                "severity_high": 5,
                "severity_medium": 4,
                "severity_low": 3,
            },
            "timing": {
                "started_at": "2025-12-03T10:00:00Z",
                "completed_at": "2025-12-03T10:15:00Z"
            },
            "rules": []  // Only if include_rules=true
        }

    Security:
        - Requires authenticated user
        - Uses QueryBuilder for SQL injection prevention
    """
    try:
        # Get scan details with host information
        builder = (
            QueryBuilder("scans s")
            .select(
                "s.id",
                "s.name",
                "s.host_id",
                "s.profile_id",
                "s.status",
                "s.progress",
                "s.result_file",
                "s.report_file",
                "s.error_message",
                "s.started_at",
                "s.completed_at",
                "s.started_by",
                "h.display_name as host_name",
                "h.hostname",
                "h.ip_address",
            )
            .join("hosts h", "s.host_id = h.id")
            .where("s.id = :id", scan_id, "id")
        )
        query, params = builder.build()
        scan_result = db.execute(text(query), params).fetchone()

        if not scan_result:
            raise HTTPException(status_code=404, detail="Scan not found")

        # Build response
        response: Dict[str, Any] = {
            "scan_id": scan_result.id,
            "name": scan_result.name,
            "status": scan_result.status,
            "progress": scan_result.progress,
            "profile_id": scan_result.profile_id,
            "host": {
                "id": str(scan_result.host_id),
                "name": scan_result.host_name,
                "hostname": scan_result.hostname,
                "ip_address": scan_result.ip_address,
            },
            "timing": {
                "started_at": (scan_result.started_at.isoformat() if scan_result.started_at else None),
                "completed_at": (scan_result.completed_at.isoformat() if scan_result.completed_at else None),
            },
            "error_message": scan_result.error_message,
            "result_file": scan_result.result_file,
            "report_file": scan_result.report_file,
        }

        # Add results summary if scan has completed
        if scan_result.status == "completed":
            results_query = db.execute(
                text(
                    """
                SELECT total_rules, passed_rules, failed_rules, error_rules,
                       unknown_rules, not_applicable_rules, score,
                       severity_high, severity_medium, severity_low
                FROM scan_results WHERE scan_id = :scan_id
            """
                ),
                {"scan_id": scan_id},
            ).fetchone()

            if results_query:
                response["results"] = {
                    "total_rules": results_query.total_rules,
                    "passed_rules": results_query.passed_rules,
                    "failed_rules": results_query.failed_rules,
                    "error_rules": results_query.error_rules,
                    "unknown_rules": results_query.unknown_rules,
                    "not_applicable_rules": results_query.not_applicable_rules,
                    "score": results_query.score,
                    "severity_high": results_query.severity_high,
                    "severity_medium": results_query.severity_medium,
                    "severity_low": results_query.severity_low,
                }
            else:
                response["results"] = None

        # Add rule-level details if requested
        if include_rules and scan_result.result_file:
            response["rules"] = []
            if os.path.exists(scan_result.result_file):
                try:
                    tree = ET.parse(scan_result.result_file)
                    root = tree.getroot()

                    namespaces = {"xccdf": "http://checklists.nist.gov/xccdf/1.2"}
                    rule_results: List[Dict[str, Any]] = []

                    for rule_result in root.findall(".//xccdf:rule-result", namespaces):
                        rule_id = rule_result.get("idref", "")
                        result_elem = rule_result.find("xccdf:result", namespaces)

                        if result_elem is not None:
                            rule_results.append(
                                {
                                    "rule_id": rule_id,
                                    "result": result_elem.text,
                                    "severity": rule_result.get("severity", "unknown"),
                                }
                            )

                    response["rules"] = rule_results
                except Exception as e:
                    logger.error(f"Error parsing rule results: {e}")
                    response["rules"] = []

        return response

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting scan results: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve scan results")


# =============================================================================
# REPORT ENDPOINTS
# =============================================================================


@router.get("/{scan_id}/report/html")
async def get_scan_html_report(
    scan_id: str,
    db: Session = Depends(get_db),
    current_user: Dict[str, Any] = Depends(get_current_user),
) -> Any:
    """
    Download scan HTML report.

    Returns the HTML report file generated by oscap during scan execution.
    The report includes visual representations of compliance status.

    Args:
        scan_id: UUID of the scan.
        db: SQLAlchemy database session.
        current_user: Authenticated user from JWT token.

    Returns:
        FileResponse with HTML report file.

    Raises:
        HTTPException 404: Scan or report file not found.
        HTTPException 500: Report retrieval failure.

    Example:
        GET /api/scans/550e8400-e29b-41d4-a716-446655440000/report/html

    Security:
        - Requires authenticated user
        - Validates file path exists before serving
    """
    try:
        # Get scan details
        result = db.execute(
            text(
                """
            SELECT report_file FROM scans WHERE id = :id
        """
            ),
            {"id": scan_id},
        ).fetchone()

        if not result or not result.report_file:
            raise HTTPException(status_code=404, detail="Report not found")

        # Check if file exists
        if not os.path.exists(result.report_file):
            raise HTTPException(status_code=404, detail="Report file not found")

        # Return file
        return FileResponse(
            result.report_file,
            media_type="text/html",
            filename=f"scan_{scan_id}_report.html",
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting HTML report: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve report")


@router.get("/{scan_id}/report/json")
async def get_scan_json_report(
    scan_id: str,
    db: Session = Depends(get_db),
    current_user: Dict[str, Any] = Depends(get_current_user),
) -> Dict[str, Any]:
    """
    Export scan results as JSON.

    Returns comprehensive scan data including rule-level details with
    remediation information when available. Enhanced parsing can be
    enabled for detailed remediation extraction.

    Args:
        scan_id: UUID of the scan.
        db: SQLAlchemy database session.
        current_user: Authenticated user from JWT token.

    Returns:
        Dictionary with complete scan data and rule results.

    Raises:
        HTTPException 404: Scan not found.
        HTTPException 500: JSON report generation failure.

    Example:
        GET /api/scans/550e8400-e29b-41d4-a716-446655440000/report/json

    Security:
        - Requires authenticated user
        - Validates file paths before parsing
    """
    try:
        # Get full scan details with results
        scan_data = await _get_scan_details(scan_id, db, current_user)

        # Add enhanced rule results with remediation if available
        if scan_data.get("status") == "completed" and scan_data.get("result_file"):
            try:
                # Get the SCAP content file path for remediation extraction
                content_file: Optional[str] = None
                content_result = db.execute(
                    text(
                        """
                    SELECT file_path FROM scap_content WHERE id = :content_id
                """
                    ),
                    {"content_id": scan_data.get("content_id")},
                ).fetchone()

                if content_result:
                    content_file = content_result.file_path

                # Temporarily disable enhanced parsing for performance (was taking 40+ seconds)
                # TODO: Implement caching or optimize the parsing logic
                enhanced_parsing_enabled = False

                enhanced_results: Dict[str, Any] = {}
                if enhanced_parsing_enabled and content_file is not None:
                    # Use engine module's result parser for enhanced SCAP parsing
                    # XCCDFResultParser provides parse_scan_results() for XCCDF result files
                    from app.services.engine.result_parsers import XCCDFResultParser

                    parser = XCCDFResultParser()
                    parsed = parser.parse_scan_results(
                        Path(scan_data["result_file"]),
                        Path(content_file),
                    )
                    # Convert parsed results to legacy format for compatibility
                    enhanced_results = {
                        "rule_details": [
                            {
                                "rule_id": r.rule_id,
                                "result": r.result,
                                "severity": r.severity,
                                "title": r.title,
                                "description": r.description,
                                "rationale": r.rationale,
                                "remediation": r.remediation,
                            }
                            for r in parsed.rules
                        ]
                    }

                # Add enhanced rule details with remediation
                if "rule_details" in enhanced_results and enhanced_results["rule_details"]:
                    scan_data["rule_results"] = enhanced_results["rule_details"]
                    logger.info(f"Added {len(enhanced_results['rule_details'])} enhanced rules " f"with remediation")
                else:
                    # Fallback to basic parsing for backward compatibility
                    if os.path.exists(scan_data["result_file"]):
                        tree = ET.parse(scan_data["result_file"])
                        root = tree.getroot()

                        # Extract basic rule results
                        namespaces = {"xccdf": "http://checklists.nist.gov/xccdf/1.2"}
                        rule_results: List[Dict[str, Any]] = []

                        for rule_result in root.findall(".//xccdf:rule-result", namespaces):
                            rule_id = rule_result.get("idref", "")
                            result_elem = rule_result.find("xccdf:result", namespaces)

                            if result_elem is not None:
                                rule_results.append(
                                    {
                                        "rule_id": rule_id,
                                        "result": result_elem.text,
                                        "severity": rule_result.get("severity", "unknown"),
                                        "title": "",
                                        "description": "",
                                        "rationale": "",
                                        "remediation": {},
                                        "references": [],
                                    }
                                )

                        scan_data["rule_results"] = rule_results
                        logger.info(f"Added {len(rule_results)} basic rules (fallback mode)")

            except Exception as e:
                logger.error(f"Error extracting enhanced rule data: {e}")
                # Maintain backward compatibility - don't break if enhancement fails
                scan_data["rule_results"] = []

        # For Aegis scans (no result_file), fetch findings from scan_findings table
        if scan_data.get("status") == "completed" and not scan_data.get("result_file"):
            try:
                findings_query = text(
                    """
                    SELECT
                        rule_id,
                        title,
                        severity,
                        status,
                        detail,
                        framework_section
                    FROM scan_findings
                    WHERE scan_id = :scan_id
                    ORDER BY
                        CASE severity
                            WHEN 'critical' THEN 1
                            WHEN 'high' THEN 2
                            WHEN 'medium' THEN 3
                            WHEN 'low' THEN 4
                            ELSE 5
                        END,
                        rule_id
                    """
                )
                findings = db.execute(findings_query, {"scan_id": scan_id}).fetchall()

                if findings:
                    rule_results = [
                        {
                            "rule_id": f.rule_id,
                            "result": f.status,  # 'pass', 'fail', 'skipped'
                            "severity": f.severity or "medium",
                            "title": f.title or f.rule_id,
                            "description": f.detail or "",
                            "rationale": "",
                            "remediation": {},
                            "references": [],
                            "framework_section": f.framework_section,
                        }
                        for f in findings
                    ]
                    scan_data["rule_results"] = rule_results
                    logger.info(f"Added {len(rule_results)} Aegis scan findings from database")
            except Exception as e:
                logger.error(f"Error fetching Aegis scan findings: {e}")
                scan_data["rule_results"] = []

        return dict(scan_data)

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting JSON report: {e}")
        raise HTTPException(status_code=500, detail="Failed to generate JSON report")


@router.get("/{scan_id}/report/csv")
async def get_scan_csv_report(
    scan_id: str,
    db: Session = Depends(get_db),
    current_user: Dict[str, Any] = Depends(get_current_user),
) -> Any:
    """
    Export scan results as CSV.

    Generates a CSV file with scan summary, statistics, and rule-level results.
    Suitable for import into spreadsheet applications.

    Args:
        scan_id: UUID of the scan.
        db: SQLAlchemy database session.
        current_user: Authenticated user from JWT token.

    Returns:
        Response with CSV content and appropriate headers.

    Raises:
        HTTPException 404: Scan not found.
        HTTPException 500: CSV report generation failure.

    Example:
        GET /api/scans/550e8400-e29b-41d4-a716-446655440000/report/csv

    Security:
        - Requires authenticated user
        - Content-Disposition header prevents browser rendering
    """
    try:
        # Get scan data including rule results
        scan_data = await get_scan_json_report(scan_id, db, current_user)

        # Create CSV content
        output = io.StringIO()
        writer = csv.writer(output)

        # Write headers
        writer.writerow(["Scan Information"])
        writer.writerow(["ID", scan_data.get("id")])
        writer.writerow(["Name", scan_data.get("name")])
        writer.writerow(["Host", scan_data.get("host_name")])
        writer.writerow(["Status", scan_data.get("status")])
        writer.writerow(["Score", scan_data.get("results", {}).get("score", "N/A")])
        writer.writerow([])

        # Write summary
        writer.writerow(["Summary Statistics"])
        writer.writerow(["Metric", "Value"])
        if scan_data.get("results"):
            results = scan_data["results"]
            writer.writerow(["Total Rules", results.get("total_rules")])
            writer.writerow(["Passed", results.get("passed_rules")])
            writer.writerow(["Failed", results.get("failed_rules")])
            writer.writerow(["Errors", results.get("error_rules")])
            writer.writerow(["High Severity", results.get("severity_high")])
            writer.writerow(["Medium Severity", results.get("severity_medium")])
            writer.writerow(["Low Severity", results.get("severity_low")])
        writer.writerow([])

        # Write rule results if available
        if "rule_results" in scan_data:
            writer.writerow(["Rule Results"])
            writer.writerow(["Rule ID", "Result", "Severity"])
            for rule in scan_data["rule_results"]:
                writer.writerow([rule.get("rule_id"), rule.get("result"), rule.get("severity")])

        # Return CSV
        return Response(
            content=output.getvalue(),
            media_type="text/csv",
            headers={"Content-Disposition": f"attachment; filename=scan_{scan_id}_report.csv"},
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating CSV report: {e}")
        raise HTTPException(status_code=500, detail="Failed to generate CSV report")


@router.get("/{scan_id}/failed-rules")
async def get_scan_failed_rules(
    scan_id: str,
    db: Session = Depends(get_db),
    current_user: Dict[str, Any] = Depends(get_current_user),
) -> Dict[str, Any]:
    """
    Get failed rules from a completed scan for AEGIS integration.

    Extracts failed rules from XCCDF result files with metadata suitable
    for remediation workflows. Optimized for integration with AEGIS.

    Args:
        scan_id: UUID of the scan.
        db: SQLAlchemy database session.
        current_user: Authenticated user from JWT token.

    Returns:
        Dictionary with scan info, host details, and list of failed rules.

    Raises:
        HTTPException 404: Scan not found.
        HTTPException 400: Scan not completed.
        HTTPException 500: Failed rules extraction failure.

    Example:
        GET /api/scans/550e8400-e29b-41d4-a716-446655440000/failed-rules

    Response Format:
        {
            "scan_id": "uuid",
            "host_id": "uuid",
            "hostname": "server.example.com",
            "failed_rules_count": 15,
            "compliance_score": "85.0%",
            "failed_rules": [
                {
                    "rule_id": "xccdf_org.ssgproject.content_rule_...",
                    "severity": "high",
                    "result": "fail",
                    "remediation_available": true
                }
            ]
        }

    Security:
        - Requires authenticated user
        - XML parsing uses standard library for security
    """
    try:
        # Verify scan exists and is completed
        scan_result = db.execute(
            text(
                """
            SELECT s.id, s.name, s.host_id, s.status, s.result_file, s.profile_id,
                   h.hostname, h.ip_address, h.display_name as host_name,
                   sr.failed_rules, sr.total_rules, sr.score
            FROM scans s
            JOIN hosts h ON s.host_id = h.id
            LEFT JOIN scan_results sr ON sr.scan_id = s.id
            WHERE s.id = :scan_id
        """
            ),
            {"scan_id": scan_id},
        ).fetchone()

        if not scan_result:
            raise HTTPException(status_code=404, detail="Scan not found")

        if scan_result.status != "completed":
            raise HTTPException(
                status_code=400,
                detail=f"Scan not completed (status: {scan_result.status})",
            )

        if not scan_result.result_file or not scan_result.failed_rules or scan_result.failed_rules == 0:
            return {
                "scan_id": scan_id,
                "host_id": str(scan_result.host_id),
                "hostname": scan_result.hostname,
                "host_name": scan_result.host_name,
                "ip_address": scan_result.ip_address,
                "total_rules": scan_result.total_rules or 0,
                "failed_rules_count": 0,
                "compliance_score": scan_result.score,
                "failed_rules": [],
            }

        # Parse the SCAP result file to extract failed rules
        failed_rules: List[Dict[str, Any]] = []
        if os.path.exists(scan_result.result_file):
            try:
                tree = ET.parse(scan_result.result_file)
                root = tree.getroot()

                # Extract failed rule results
                namespaces = {"xccdf": "http://checklists.nist.gov/xccdf/1.2"}

                for rule_result in root.findall(".//xccdf:rule-result", namespaces):
                    result_elem = rule_result.find("xccdf:result", namespaces)

                    if result_elem is not None and result_elem.text == "fail":
                        rule_id = rule_result.get("idref", "")
                        severity = rule_result.get("severity", "unknown")

                        # Extract additional metadata if available
                        check_elem = rule_result.find("xccdf:check", namespaces)
                        check_content_ref = ""
                        if check_elem is not None:
                            content_ref = check_elem.find("xccdf:check-content-ref", namespaces)
                            if content_ref is not None:
                                check_content_ref = content_ref.get("href", "")

                        failed_rule = {
                            "rule_id": rule_id,
                            "severity": severity,
                            "result": "fail",
                            "check_content_ref": check_content_ref,
                            "remediation_available": True,  # Assume remediation available for AEGIS
                        }

                        failed_rules.append(failed_rule)

            except Exception as e:
                logger.error(f"Error parsing scan results for failed rules: {e}")
                # Return basic info even if parsing fails

        response_data = {
            "scan_id": scan_id,
            "host_id": str(scan_result.host_id),
            "hostname": scan_result.hostname,
            "host_name": scan_result.host_name,
            "ip_address": scan_result.ip_address,
            "scan_name": scan_result.name,
            "profile_id": scan_result.profile_id,
            "total_rules": scan_result.total_rules or 0,
            "failed_rules_count": len(failed_rules),
            "compliance_score": scan_result.score,
            "failed_rules": failed_rules,
        }

        logger.info(f"Retrieved {len(failed_rules)} failed rules for scan {scan_id}")
        return response_data

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting failed rules: {e}")
        raise HTTPException(status_code=500, detail="Failed to retrieve failed rules")


# =============================================================================
# PUBLIC API EXPORTS
# =============================================================================

__all__ = [
    "router",
    "get_scan_results",
    "get_scan_html_report",
    "get_scan_json_report",
    "get_scan_csv_report",
    "get_scan_failed_rules",
]
