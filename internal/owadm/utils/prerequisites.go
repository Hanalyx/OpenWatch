package utils

import (
	"fmt"
	"os"
	"os/exec"
	goruntime "runtime"
)

// CheckPrerequisites checks if all required tools and conditions are met
func CheckPrerequisites() error {
	// Check if running as non-root (recommended for rootless containers)
	if goruntime.GOOS != "windows" && os.Geteuid() == 0 {
		// This is just a warning, not an error
		fmt.Println("WARNING: Running as root user. Consider using rootless containers for better security.")
	}
	
	// Check for container runtime (at least one must be available)
	hasDocker := isCommandAvailable("docker")
	hasPodman := isCommandAvailable("podman")
	
	if !hasDocker && !hasPodman {
		return fmt.Errorf("no container runtime found. Please install Docker or Podman")
	}
	
	// Check for compose command
	if hasDocker && !isCommandAvailable("docker-compose") {
		// Check for docker compose plugin
		if err := exec.Command("docker", "compose", "version").Run(); err != nil {
			return fmt.Errorf("docker-compose not found. Please install docker-compose or Docker Compose plugin")
		}
	}
	
	if hasPodman && !isCommandAvailable("podman-compose") {
		return fmt.Errorf("podman-compose not found. Please install podman-compose")
	}
	
	// Check for required tools for key generation
	if !isCommandAvailable("openssl") {
		return fmt.Errorf("openssl not found. Please install openssl for security key generation")
	}
	
	return nil
}

// isCommandAvailable checks if a command exists in PATH
func isCommandAvailable(command string) bool {
	_, err := exec.LookPath(command)
	return err == nil
}

// CheckEnvironmentFiles checks if required environment files exist
func CheckEnvironmentFiles() error {
	// Check for .env file
	if _, err := os.Stat(".env"); os.IsNotExist(err) {
		return fmt.Errorf(".env file not found")
	}
	
	// Check if we're in a development OpenWatch directory
	// In production installations, these source files won't exist
	requiredFiles := []string{
		"docker-compose.yml",
		"backend/app/main.py",
		"frontend/package.json",
	}
	
	// Check if ANY of the development files exist
	// If none exist, we're likely in a production installation
	developmentFilesFound := 0
	for _, file := range requiredFiles {
		if _, err := os.Stat(file); err == nil {
			developmentFilesFound++
		}
	}
	
	// If we find some but not all files, it's an incomplete installation
	if developmentFilesFound > 0 && developmentFilesFound < len(requiredFiles) {
		for _, file := range requiredFiles {
			if _, err := os.Stat(file); os.IsNotExist(err) {
				return fmt.Errorf("incomplete OpenWatch directory (missing %s)", file)
			}
		}
	}
	
	// If no development files found, assume production installation
	if developmentFilesFound == 0 {
		return fmt.Errorf("production installation detected (source files not present)")
	}
	
	return nil
}

// CreateDefaultEnvFile creates a default .env file with secure random values
func CreateDefaultEnvFile() error {
	// Check if .env already exists
	if _, err := os.Stat(".env"); err == nil {
		return nil // File already exists
	}
	
	// Generate secure random values
	secretKey := generateRandomString(32)
	dbPassword := generateRandomString(24)
	redisPassword := generateRandomString(24)
	jwtSecret := generateRandomString(32)
	
	// Create .env content
	envContent := fmt.Sprintf(`# OpenWatch Environment Configuration
# Generated by owadm

# Application Settings
APP_ENV=production
DEBUG=false

# Security Keys
SECRET_KEY=%s
JWT_SECRET=%s

# Database Configuration
POSTGRES_PASSWORD=%s
POSTGRES_USER=openwatch
POSTGRES_DB=openwatch
DATABASE_URL=postgresql://openwatch:%s@database:5432/openwatch

# Redis Configuration
REDIS_PASSWORD=%s
REDIS_URL=redis://:%s@redis:6379/0

# API Configuration
API_HOST=0.0.0.0
API_PORT=8000

# Frontend Configuration
VITE_API_BASE_URL=http://localhost:8000

# Celery Configuration
CELERY_BROKER_URL=redis://:%s@redis:6379/1
CELERY_RESULT_BACKEND=redis://:%s@redis:6379/2

# CORS Settings
CORS_ORIGINS=["http://localhost:3000", "http://localhost:3001"]
`, secretKey, jwtSecret, dbPassword, dbPassword, redisPassword, redisPassword, redisPassword, redisPassword)
	
	// Write .env file
	return os.WriteFile(".env", []byte(envContent), 0600)
}

// CreateRequiredDirectories creates all required directories for OpenWatch
func CreateRequiredDirectories() error {
	directories := []string{
		"logs",
		"data/scap",
		"data/results", 
		"data/uploads",
		"security/certs",
		"security/keys",
		"backend/logs",
		"backend/security/keys",
	}
	
	for _, dir := range directories {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}
	
	// Set more restrictive permissions on security directories
	securityDirs := []string{"security/keys", "backend/security/keys"}
	for _, dir := range securityDirs {
		// Check if directory exists and get current permissions
		if info, err := os.Stat(dir); err == nil {
			// Directory exists - check if permissions are already correct
			if info.Mode().Perm() == 0700 {
				continue // Skip - already has correct permissions
			}
		}
		
		// Try to set permissions, but don't fail if we can't (production constraint)
		if err := os.Chmod(dir, 0700); err != nil {
			fmt.Printf("WARNING: Could not set permissions on %s: %v (continuing anyway)\n", dir, err)
			continue // Don't fail the entire operation
		}
	}
	
	return nil
}

// EnsureSecurityKeys ensures JWT keys exist
func EnsureSecurityKeys() error {
	keyPaths := []struct {
		privateKey string
		publicKey  string
	}{
		{
			privateKey: "security/keys/jwt_private.pem",
			publicKey:  "security/keys/jwt_public.pem",
		},
		{
			privateKey: "backend/security/keys/jwt_private.pem", 
			publicKey:  "backend/security/keys/jwt_public.pem",
		},
	}
	
	for _, keys := range keyPaths {
		// Check if keys already exist
		if _, err := os.Stat(keys.privateKey); err == nil {
			continue // Keys already exist
		}
		
		// Generate RSA key pair
		if err := exec.Command("openssl", "genrsa", "-out", keys.privateKey, "2048").Run(); err != nil {
			return fmt.Errorf("failed to generate private key: %w", err)
		}
		
		// Extract public key
		if err := exec.Command("openssl", "rsa", "-in", keys.privateKey, "-pubout", "-out", keys.publicKey).Run(); err != nil {
			return fmt.Errorf("failed to generate public key: %w", err)
		}
		
		// Set appropriate permissions
		if err := os.Chmod(keys.privateKey, 0600); err != nil {
			return fmt.Errorf("failed to set permissions on private key: %w", err)
		}
		
		if err := os.Chmod(keys.publicKey, 0644); err != nil {
			return fmt.Errorf("failed to set permissions on public key: %w", err)
		}
	}
	
	return nil
}